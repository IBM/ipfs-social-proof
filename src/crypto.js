const TextDecoder = require('text-encoding').TextDecoder
const TextEncoder = require('text-encoding').TextEncoder
const { Buffer } = require('buffer')
const multihashing = require('multihashing-async')
const { pem, pki } = require('node-forge')
const peerId = require('peer-id')

const { log, error } = require('./log')

const { OBJECT, STRING, UNDEFINED,
        ARRAY, INTEGER, BOOL } = require('./utils')

const SHA_256 = 'sha2-256'

class Crypto {

  constructor (node) {
    if (!node) { throw new Error('IPFS node is required') }
    this._node = node
    this._crypto = this._node.util.crypto // libp2pCrypto
  }

  get identity () {
    if (this._identity) {
      return this._identity
    }
    error('Set identity object required')
    return null
  }

  set identity (identity) {
    if (!identity) {
      throw new Error('Identity object required')
    }
    this._identity = identity
  }

  get node () {
    return this._node
  }

  verifyProof (proof, callback) {
    // make sure the proof signature was
    // generated by the private half of publicKey
    let _proof
    if (typeof proof == STRING) {
      _proof = JSON.parse(proof)
    } else {
      _proof = proof
    }
    if (proof.doc) {
      _proof = proof.doc
    }
    // TODO: revert to using helper functions and test
    //       `this` was undefined here being called from PublicKeyCard
    //        which, BTW, was called from a DOM eventHandler, so not bound
    const signedProofText = JSON.stringify(_proof.proof) // JSON -> string
    // const bufferSig = this.rehydrate(_proof.signature) //  string -> encode to arraybuffer
    const obj = JSON.parse(_proof.signature)
    // Get the Uint8Array version of the stringified data (key or signature)
    const bufferSig = Buffer.from(obj.data)
    // const publicKey = this.unmarshalPubKey(_proof.publicKey) // Instanciate RsaPubKey
    const objKey = JSON.parse(_proof.publicKey)
    // Get the Uint8Array version of the stringified key
    const bufferKey = Buffer.from(objKey)
    // unmarshal pub key (any pub key)
    const publicKey = this._crypto.keys.unmarshalPublicKey(bufferKey)

    const textArr = t2a(signedProofText) // encode text to array
    // check the signature in the proof
    return publicKey.verify(textArr, bufferSig, callback)
  }

  verify (signedString, signature, callback) {
    // signed string must be raw buffer, not base64!
    let array = t2a(signedString)

    this.node._peerInfo.id._pubKey.verify(
      array,
      signature, (err, verified) => {
        log(err, verified)
        if (err) { throw new Error(err) }
        callback(err, verified)
      })
  }

  sign (stringToSign, callback) {
     // make an array buffer from string to sign the arrayBuffer
    let array = t2a(stringToSign)

    this.node._peerInfo.id._privKey.sign(array, (err, signature) => {
      log(err, signature)
      callback(err, signature)
    })
  }

  get pubKeyDehydrated () {
    // get a base64 encoded marshaled pub key
    const pub = this.node._peerInfo.id._privKey.public
    const mk = this._crypto.keys.marshalPublicKey(pub)
    return this.dehydrate(mk)
  }

  unmarshalPubKey (stringifiedKey) {
    const obj = JSON.parse(stringifiedKey)
    // Get the Uint8Array version of the stringified key
    const bufferKey = Buffer.from(obj.data)
    // unmarshal pub key (any pub key)
    const umpk = this._crypto.keys.unmarshalPublicKey(bufferKey)
    return umpk // now, one can use this pub key to verify signatures
  }

  dehydrate (buff) {
    return JSON.stringify(buff)
  }

  rehydrate (jsonStr) {
    // re-hydrate a json string back into an Uint8Array
    // expecting a string like so: '{"data": [0,2,5,7,12,34,122...]}'
    const obj = JSON.parse(jsonStr)
    // Get the Uint8Array version of the stringified data (key or signature)
    const buff = Buffer.from(obj.data)
    return buff
  }

  get pubKeyBase64 () {
    return this.pubKeyPem
  }

  get pubKeyPem () {
    let pk = this.node._peerInfo.id._privKey.public._key
    return pki.publicKeyToPem(pk)
  }

  convertRsaPubKeyToPem (rsaPubKey) {
    let rpk
    if (rsaPubKey._key) {
      rpk = rsaPubKey._key
    } else {
      rpk = rsaPubKey
    }
    return pki.publicKeyToPem(rpk)
  }

  convertPemPubKeyToRsa (pemPubKey) {
    return pki.publicKeyFromPem(pemPubKey);
  }

  armor (base64Str, format='pk') {
    // pk = public key
    // sig = signature
    if (!base64Str || !format) {
      throw new Error(ERR.ARG_REQ_BASE64_STR)
    }

    const formats = {
      pk: {
        head: '-----BEGIN PUBLIC KEY-----\r\n',
        tail: '\r\n-----END PUBLIC KEY-----'
      },
      sig: {
        head: '-----BEGIN PGP MESSAGE-----\r\n',
        tail: '\r\n-----END PGP MESSAGE-----'
      }
    }

    let key = ''

    for (var i = 0; i < base64Str.length; i++) {
      if ((i % 64) === 0) {
        key += '\n';
      }
      key += base64Str.charAt(i);
    }

    if (!/\\n$/.test(key)) {
      key += '\r\n';
    }

    return `${formats[format].head}${key}${formats[format].tail}`.trim();
  }

  armorSignature (signature, native=true) {
    if (native) {
      return this.armor(a2t(signature), 'sig')
    } else {
      // already base64'd
      return this.armor(signature, 'sig')
    }
  }

  // async verifyPeer (peerProfile, saveContact=false) {
  //   const that = this
  //   let proofs = []
  //   if (peerProfile.peerId === this.identity.peerId) {
  //     // verifying self
  //     // let _proofs = await this.idData.getProofs()
  //     proofs = _proofs.rows || []
  //   } else {
  //     if (!peerProfile.proofs) {
  //       return
  //     }
  //     if (!peerProfile.proofs.length) {
  //       return
  //     }
  //     proofs = peerProfile.proofs
  //   }

  //   let proofDocs = []
  //   proofs.forEach((proof, idx) => {
  //     that.verifyProof(proof.proof, (err, valid) => {
  //       var valid = false
  //       if (err) {
  //         valid = false
  //       } else {
  //         valid = true
  //       }
  //       proofDocs.push({proof: proof.proof, valid: valid, ts: Date.now()})
  //     })
  //   })
  //   if (saveContact) {
  //     let contact = peerProfile
  //     contact.validityDocs = proofDocs
  //     that.contactsDB.upsert(peerProfile.peerId, contact).
  //       then((res) => {
  //         console.log('contact saved')
  //         // TODO: set state in a notify component that will give feedback
  //       }).catch((ex) => {
  //         console.error(ex)
  //       })
  //   }
  // }

  getMultihashForStringContent (stringContent, callback) {
    // pass in content you need a multihash for in order to
    // see if the file exists on IPFS
    //  NOTE: this will not work - it will just timeout
    const that = this;
    let buf = Buffer.from(stringContent)

    multihashing(buf, SHA_256, (err, mh) => {
      if (err) {
        return callback(err, null)
      }
      let b58Str = that.node.types.multihash.toB58String(mh)
      callback(null, b58Str)
    })
  }
}

function t2a (text) {
  return new TextEncoder("utf-8").encode(text)
}

function a2t (arrayBuffer) {
  return new TextDecoder("utf-8").decode(arrayBuffer)
}

function a2c (arrayBuffer) {
  let text = []
  arrayBuffer.forEach((el) => {
    text.push(String.fromCharCode(el))
  })
  log('text array inside a2c', text)
  return text.join('')
}

module.exports = {
  Crypto: Crypto,
  t2a: t2a,
  a2t: a2t,
  atc: a2c
}
