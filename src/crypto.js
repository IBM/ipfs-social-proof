const TextDecoder = require('text-encoding').TextDecoder
const TextEncoder = require('text-encoding').TextEncoder
const { Buffer } = require('buffer')
const forge = require('node-forge')

const { log, error } = require('./log')

const { OBJECT, STRING, UNDEFINED,
        ARRAY, INTEGER, BOOL } = require('./utils')

const SHA_256 = 'sha2-256'

class Crypto {

  constructor (node) {
    if (!node) { throw new Error('IPFS node is required') }
    this._node = node
    this._crypto = this._node.util.crypto // libp2pCrypto
  }

  get node () {
    return this._node
  }

  verifyProof (proof, callback) {
    // make sure the proof signature was
    // generated by the private half of publicKey
    let _proof
    if (typeof proof == STRING) {
      _proof = JSON.parse(proof)
    } else {
      _proof = proof
    }
    if (proof.doc) {
      _proof = proof.doc
    }

    const signedProofText = JSON.stringify(_proof.proof) // JSON -> string

    const obj = JSON.parse(_proof.signature)
    // Get the Uint8Array version of the stringified data (key or signature)
    const bufferSig = Buffer.from(obj)

    const objKey = JSON.parse(_proof.publicKey)
    // Get the Uint8Array version of the stringified key
    const bufferKey = Buffer.from(objKey)
    // unmarshal pub key (any pub key)
    const publicKey = this._crypto.keys.unmarshalPublicKey(bufferKey)

    const textArr = t2a(signedProofText) // encode text to array
    // check the signature in the proof
    return publicKey.verify(textArr, bufferSig, callback)
  }

  verify (signedString, signature, callback) {
    // signed string must be raw buffer, not base64!
    let array = t2a(signedString)

    this.node._peerInfo.id._pubKey.verify(
      array,
      signature, (err, verified) => {
        if (err) { throw new Error(err) }
        callback(err, verified)
      })
  }

  sign (stringToSign, callback) {
     // make an array buffer from string to sign the arrayBuffer
    let array = t2a(stringToSign)

    this.node._peerInfo.id._privKey.sign(array, (err, signature) => {
      callback(err, signature)
    })
  }

  get pubKeyDehydrated () {
    // get a base64 encoded marshaled pub key
    const pub = this.node._peerInfo.id._privKey.public
    const mk = this._crypto.keys.marshalPublicKey(pub)
    return this.dehydrate(mk)
  }

  dehydrate (buff) {
    let s = JSON.stringify(buff)
    let arr = JSON.parse(s).data
    return JSON.stringify(arr)
  }

  rehydrate (jsonStr) {
    // re-hydrate a json string back into an Uint8Array
    // expecting a string like so: '{"data": [0,2,5,7,12,34,122...]}'
    const obj = JSON.parse(jsonStr)
    // Get the Uint8Array version of the stringified data (key or signature)
    const buff = Buffer.from(obj)
    return buff
  }

  get pubKeyBase64 () {
    return this.pubKeyPem
  }

  get pubKeyPem () {
    return this.pubKeyPemFromJwk
  }

  get pubKeyPemFromJwk () {
    return this.convertJwkPubKeyToPem(
      this.node._peerInfo.id._privKey.public._key
    )
  }

  convertJwkPubKeyToPem (jwkPubKey) {
    if (!jwkPubKey) { throw new Erorr('jwkPubKey required') }

    let pk = this.convertJwkPubKeyToRsaPubKey(jwkPubKey)

    return forge.pki.publicKeyToPem(pk)
  }

  convertJwkPubKeyToRsaPubKey (jwkPubKey) {
    // see: https://github.com/digitalbazaar/forge/issues/444#issuecomment-264224314
    function base64urlToBigInteger(str) {
      var bytes = forge.util.decode64(
        (str + '==='.slice((str.length + 3) % 4))
          .replace(/\-/g, '+')
          .replace(/_/g, '/'));

      return new forge.jsbn.BigInteger(forge.util.bytesToHex(bytes), 16)
    }

    let rpk
    if (jwkPubKey._key) {
      rpk = jwkPubKey._key
    } else {
      rpk = jwkPubKey
    }

    let pk = forge.pki.setRsaPublicKey(
      base64urlToBigInteger(rpk.n),
      base64urlToBigInteger(rpk.e)
    )

    return pk
  }

  convertRsaPubKeyToPem (rsaPubKey) {
    let rpk
    if (rsaPubKey._key) {
      rpk = rsaPubKey._key
    } else {
      rpk = rsaPubKey
    }
    return forge.pki.publicKeyToPem(rpk)
  }

  convertPemPubKeyToRsa (pemPubKey) {
    return forge.pki.publicKeyFromPem(pemPubKey)
  }
}

function t2a (text) {
  return new TextEncoder("utf-8").encode(text)
}

function a2t (arrayBuffer) {
  return new TextDecoder("utf-8").decode(arrayBuffer)
}

function a2c (arrayBuffer) {
  let text = []
  arrayBuffer.forEach((el) => {
    text.push(String.fromCharCode(el))
  })

  return text.join('')
}

module.exports = {
  Crypto: Crypto,
  t2a: t2a,
  a2t: a2t,
  a2c: a2c
}
